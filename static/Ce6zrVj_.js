import{a as B,be as u,r as h,Y as O,bd as M,aR as R,X as T,F as E,ak as v,bf as H,N as S,I as V,bg as j,bh as z}from"./BHeDfaNv.js";const N=a=>a==="defer"||a===!1;function U(...a){var p;const i=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&a.unshift(i);let[s,f,e={}]=a;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=B(),b=f,P=()=>u.value,w=()=>t.isHydrating?t.payload.data[s]:t.static.data[s];e.server=e.server??!0,e.default=e.default??P,e.getCachedData=e.getCachedData??w,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??u.deep,e.dedupe=e.dedupe??"cancel";const y=e.getCachedData(s,t),m=y!=null;if(!t._asyncData[s]||!e.immediate){(p=t.payload._errors)[s]??(p[s]=u.errorValue);const o=e.deep?h:O;t._asyncData[s]={data:o(m?y:e.default()),pending:h(!m),error:M(t.payload._errors,s),status:h("idle"),_default:e.default}}const r={...t._asyncData[s]};delete r._default,r.refresh=r.execute=(o={})=>{if(t._asyncDataPromises[s]){if(N(o.dedupe??e.dedupe))return t._asyncDataPromises[s];t._asyncDataPromises[s].cancelled=!0}if(o._initial||t.isHydrating&&o._initial!==!1){const c=o._initial?y:e.getCachedData(s,t);if(c!=null)return Promise.resolve(c)}r.pending.value=!0,r.status.value="pending";const l=new Promise((c,n)=>{try{c(b(t))}catch(D){n(D)}}).then(async c=>{if(l.cancelled)return t._asyncDataPromises[s];let n=c;e.transform&&(n=await e.transform(c)),e.pick&&(n=I(n,e.pick)),t.payload.data[s]=n,r.data.value=n,r.error.value=u.errorValue,r.status.value="success"}).catch(c=>{if(l.cancelled)return t._asyncDataPromises[s];r.error.value=H(c),r.data.value=S(e.default()),r.status.value="error"}).finally(()=>{l.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[s])});return t._asyncDataPromises[s]=l,t._asyncDataPromises[s]},r.clear=()=>F(t,s);const _=()=>r.refresh({_initial:!0}),C=e.server!==!1&&t.payload.serverRendered;{const o=V();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const n=o._nuxtOnBeforeMountCbs;R(()=>{n.forEach(D=>{D()}),n.splice(0,n.length)}),T(()=>n.splice(0,n.length))}C&&t.isHydrating&&(r.error.value||y!=null)?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(_):e.immediate&&_();const l=j();if(e.watch){const n=E(e.watch,()=>r.refresh());l&&v(n)}const c=t.hook("app:data:refresh",async n=>{(!n||n.includes(s))&&await r.refresh()});l&&v(c)}const g=Promise.resolve(t._asyncDataPromises[s]).then(()=>r);return Object.assign(g,r),g}function F(a,i){i in a.payload.data&&(a.payload.data[i]=void 0),i in a.payload._errors&&(a.payload._errors[i]=u.errorValue),a._asyncData[i]&&(a._asyncData[i].data.value=void 0,a._asyncData[i].error.value=u.errorValue,a._asyncData[i].pending.value=!1,a._asyncData[i].status.value="idle"),i in a._asyncDataPromises&&(a._asyncDataPromises[i]&&(a._asyncDataPromises[i].cancelled=!0),a._asyncDataPromises[i]=void 0)}function I(a,i){const s={};for(const f of i)s[f]=a[f];return s}const d=z.create();d.interceptors.response.use(function(a){if(a.data.code==200)return a.data.data;a.data.code==500?console.log(500):console.log(a.data.code)},function(a){return Promise.reject(a)});const X=async()=>await d.get("/api/dashboard"),Y=async()=>await d.get("/api/dashboard/pie"),q=async()=>await d.get("/api/dashboard/bar"),x=async a=>await d.get("/api/table/list",{params:a}),G=async a=>await d.post("/api/table/delete",a),J=async a=>await d.post("/api/table/edit",a);export{Y as a,q as b,x as c,G as d,J as e,X as g,U as u};
