import{a as B,be as u,r as h,Y as O,bd as M,aR as R,X as T,F as E,ak as v,bf as H,N as S,I as V,bg as j,bh as z}from"./C2i97U5I.js";const N=a=>a==="defer"||a===!1;function U(...a){var p;const n=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&a.unshift(n);let[s,f,e={}]=a;if(typeof s!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=B(),b=f,P=()=>u.value,w=()=>t.isHydrating?t.payload.data[s]:t.static.data[s];e.server=e.server??!0,e.default=e.default??P,e.getCachedData=e.getCachedData??w,e.lazy=e.lazy??!1,e.immediate=e.immediate??!0,e.deep=e.deep??u.deep,e.dedupe=e.dedupe??"cancel";const y=e.getCachedData(s,t),m=y!=null;if(!t._asyncData[s]||!e.immediate){(p=t.payload._errors)[s]??(p[s]=u.errorValue);const i=e.deep?h:O;t._asyncData[s]={data:i(m?y:e.default()),pending:h(!m),error:M(t.payload._errors,s),status:h("idle"),_default:e.default}}const r={...t._asyncData[s]};delete r._default,r.refresh=r.execute=(i={})=>{if(t._asyncDataPromises[s]){if(N(i.dedupe??e.dedupe))return t._asyncDataPromises[s];t._asyncDataPromises[s].cancelled=!0}if(i._initial||t.isHydrating&&i._initial!==!1){const c=i._initial?y:e.getCachedData(s,t);if(c!=null)return Promise.resolve(c)}r.pending.value=!0,r.status.value="pending";const d=new Promise((c,o)=>{try{c(b(t))}catch(D){o(D)}}).then(async c=>{if(d.cancelled)return t._asyncDataPromises[s];let o=c;e.transform&&(o=await e.transform(c)),e.pick&&(o=I(o,e.pick)),t.payload.data[s]=o,r.data.value=o,r.error.value=u.errorValue,r.status.value="success"}).catch(c=>{if(d.cancelled)return t._asyncDataPromises[s];r.error.value=H(c),r.data.value=S(e.default()),r.status.value="error"}).finally(()=>{d.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[s])});return t._asyncDataPromises[s]=d,t._asyncDataPromises[s]},r.clear=()=>F(t,s);const _=()=>r.refresh({_initial:!0}),C=e.server!==!1&&t.payload.serverRendered;{const i=V();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const o=i._nuxtOnBeforeMountCbs;R(()=>{o.forEach(D=>{D()}),o.splice(0,o.length)}),T(()=>o.splice(0,o.length))}C&&t.isHydrating&&(r.error.value||y!=null)?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):i&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?i._nuxtOnBeforeMountCbs.push(_):e.immediate&&_();const d=j();if(e.watch){const o=E(e.watch,()=>r.refresh());d&&v(o)}const c=t.hook("app:data:refresh",async o=>{(!o||o.includes(s))&&await r.refresh()});d&&v(c)}const g=Promise.resolve(t._asyncDataPromises[s]).then(()=>r);return Object.assign(g,r),g}function F(a,n){n in a.payload.data&&(a.payload.data[n]=void 0),n in a.payload._errors&&(a.payload._errors[n]=u.errorValue),a._asyncData[n]&&(a._asyncData[n].data.value=void 0,a._asyncData[n].error.value=u.errorValue,a._asyncData[n].pending.value=!1,a._asyncData[n].status.value="idle"),n in a._asyncDataPromises&&(a._asyncDataPromises[n]&&(a._asyncDataPromises[n].cancelled=!0),a._asyncDataPromises[n]=void 0)}function I(a,n){const s={};for(const f of n)s[f]=a[f];return s}const l=z.create();l.interceptors.response.use(function(a){if(a.data.code==200)return a.data.data;a.data.code==500?console.log(500):console.log(a.data.code)},function(a){return Promise.reject(a)});const X=async()=>await l.get("/api/dashboard"),Y=async()=>await l.get("/api/dashboard/pie"),q=async()=>await l.get("/api/dashboard/bar"),x=async a=>await l.get("/api/table/list",{params:a}),G=async a=>await l.post("/api/table/delete",a),J=async a=>await l.post("/api/table/edit",a);export{Y as a,q as b,x as c,G as d,J as e,X as g,U as u};
